<?xml version="1.0"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>Twisted Documentation: Waves and Harmonics</title><link href="py4fun.css" type="text/css" rel="stylesheet" /></head><body bgcolor="white"><h1 class="title">Waves and Harmonics</h1><div class="toc"><ol><li><a href="#auto0">Sound waves</a></li><li><a href="#auto1">A Python Class for Waves</a></li><li><a href="#auto2">Just Enough Tkinter</a></li><li><a href="#auto3">Complex Waveforms</a></li><li><a href="#auto4">Fourier Analysis of a Mystery Wave</a></li><li><a href="#auto5">Where from here?</a></li></ol></div><div class="content"><span></span><p>The book &quot;Who is Fourier, a Mathematical Adventure&quot; from the Transnational
College of LEX is an excellent and gentle introduction to a wide range of
subjects including differential and integral calculus, Fourier Series,
and even an analysis of the five vowel sounds used in the Japanese language. This
study augments the book by preparing an object class for representing
waveforms graphically and also manipulating them. If you can't get a copy
of the book but have some background in trig and maybe just a bit of
calculus, the material should be easy.</p><h2>Sound waves<a name="auto0"></a></h2><p>When a tuning fork is struck a sound of a single fixed frequency is emitted
as the fork vibrates. If we use a microphone to convert the sound wave to an
electrical signal and then display the signal on an oscilloscope
the waveform will look the following sine wave.</p><p><img src="fig0.jpeg" /></p><p>The horizontal axis represents time and the vertical axis amplitude.
An amplitude may represent several things such as the exact position
of the tuning fork arm as it vibrates or the compression and decompression
of air as the sound travels through it or perhaps the instantaneous voltage
of the electical signal generated by the microphone. Each seperate
point is also a point in time. The
sine wave describes how any of these properties change during a single cycle.
If the frequency is 440 cycles per second (440 Hertz) then the time shown above is
1/440 of a second.
Only two attributes are needed to describe a sine wave; its frequency
and its amplitude.</p><p>If you now strike the A above middle C on a (well tuned) piano, you will also
get a wave of 440 cycles per second. However it will not sound quite the
same as a tuning fork. And it will look quite different on the oscilloscope.
And if you play the same note on a violin or trumpet
they will sound different yet again.</p><p>The reason for the difference in sound is that these more complex
instruments produce a sine wave not only at 440 hertz but also at higher
frequencies (harmonics) where each frequency is an integer multiple of 440 hertz.
To picture this think of a violin string vibrating so that the end points
are fixed and the middle of the string vibrates back and forth. That would
be the fundamental frequency of, say, 440 hertz. Next think of the center
of the string also staying stationary and the points at 1/4 and 3/4 of
the string length vibrating back and forth. That vibration would be
at 880 hertz because the length of a vibrating string (or part of a string)
determines the frequency and the relationship is a linear one. That means
is you half the length of the string you will double the frequency.
You can divide the string into any number of sections and get a vibration
at the corresponding frequency. These vibrations are called standing
waves.</p><p>Each instrument produces its unique pattern of harmonics and their relative
strengths determine the characteristic sound of the instrument.</p><p>Now suppose we would like to play music from our computer. One way to
do this is to capture a sound wave electrically with a microphone,
convert instantaneous voltage values at some fixed rate and store the
values for later retrieval. This is exactly how a music CD works. But
it takes a lot of storage, as you already may know. About 10 megabytes for
each minute of sound.</p><p>But a much more compact method exists if the sounds are relatively simple
such as notes from trumpet or violin (or even japanese vowels). All we need
to know is the base frequency and amplitude of a note, its duration,  and
the relative amplitudes of each harmonic. Of course, there are an infinite
number of harmonics but ones that are beyond the range of human hearing
(about 20,000 Hertz) may be ignored since you wouldn't hear them anyway.</p><p>The main point of this study is to demonstrate Fourier's method for finding
the harmonic amplitudes from a sampled wave.</p><h2>A Python Class for Waves<a name="auto1"></a></h2><p>Let's start by creating a Python class to store a single cycle of a complex
waveform (like a violin note) in the same way a CD stores the information.
The data might be gathered by sampling a microphone. One attribute of
our class will be an array, or list, of sampled points. With our wave class
we will be able to add, multiply, divide, and subtract waves in order to
add in (and subtract out) harmonic frequencies. The class will also have a
method to plot the wave on the screen.</p><p>We'll use just a bit of the Tkinter package to plot the waves. Normally
the learning curve for Tkinter is fairly steep but we will be able to
accomplish our needs with just a few commands.</p><p>Let's look at the definition of the wave class. To see the code in full
<a href="wave.py">Click here</a>.</p><pre class="python">
<span class="py-src-keyword">class</span> <span class="py-src-identifier">wave</span> :
   <span class="py-src-keyword">def</span> <span class="py-src-identifier">__init__</span> (<span class="py-src-parameter">self</span>, <span class="py-src-parameter">points</span>=<span class="py-src-number">400</span>, <span class="py-src-parameter">formula</span>=<span class="py-src-parameter">None</span>) :
      <span class="py-src-variable">self</span>.<span class="py-src-variable">data</span> = [<span class="py-src-number">0.0</span>]*<span class="py-src-variable">points</span>
      <span class="py-src-variable">self</span>.<span class="py-src-variable">points</span>= <span class="py-src-variable">points</span>
      <span class="py-src-keyword">if</span> <span class="py-src-variable">formula</span> :
         <span class="py-src-keyword">for</span> <span class="py-src-variable">p</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">range</span>(<span class="py-src-variable">points</span>) :
            <span class="py-src-variable">x</span> = <span class="py-src-variable">p</span>*<span class="py-src-variable">pi</span>*<span class="py-src-number">2</span>/<span class="py-src-variable">points</span>
            <span class="py-src-variable">self</span>.<span class="py-src-variable">data</span>[<span class="py-src-variable">p</span>] = <span class="py-src-variable">eval</span>(<span class="py-src-variable">formula</span>)
</pre><p>When a wave object is instantiated we pass the number of data points
that are to be stored for the range 0 to 2*pi and also an optional formula for
calculating the data points. The formula is a string (like &quot;sin(x)&quot;)
that is passed to the Python eval
function which calculates the value of each data point. The formula should
contain a single variable &quot;x&quot; which will be iterated over the range.
Let's look at an example. We'll create a sine wave with 400 data points.</p><pre class="python-interpreter">
&gt;&gt;&gt; import wave
&gt;&gt;&gt; w = wave.wave(formula=&quot;sin(x)&quot;,points=400)
&gt;&gt;&gt; print w.data[0],w.data[100],w.data[200],w.data[300]
0.0 1.0 1.22460635382e-16 -1.0
&gt;&gt;&gt;
</pre><p>Since there are 400 data points, 100 corresponds to pi/2, 200 to pi,
and 300 to 3*pi/2. 1.22460635382e-16 is *very* close to zero, in fact we
could also write it as .0000000000000000122460635382. The reason it's not
exactly zero is due to rounding errors in the floating point calculations.</p><p>Next we define the methods to add and multiply waves. By using Pythons magic
method __add__ we're able to use the '+' operator directly on two
wave objects creating a third objects whose data points are the sum of
the corresponding data points in the input waves.</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">__add__</span> (<span class="py-src-parameter">self</span>, <span class="py-src-parameter">other</span>) :
   <span class="py-src-variable">target</span> = <span class="py-src-variable">wave</span>(<span class="py-src-variable">points</span>=<span class="py-src-variable">self</span>.<span class="py-src-variable">points</span>)
   <span class="py-src-keyword">for</span> <span class="py-src-variable">i</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">range</span>(<span class="py-src-variable">self</span>.<span class="py-src-variable">points</span>) :
      <span class="py-src-variable">target</span>.<span class="py-src-variable">data</span>[<span class="py-src-variable">i</span>] = <span class="py-src-variable">self</span>.<span class="py-src-variable">data</span>[<span class="py-src-variable">i</span>] + <span class="py-src-variable">other</span>.<span class="py-src-variable">data</span>[<span class="py-src-variable">i</span>]
   <span class="py-src-keyword">return</span> <span class="py-src-variable">target</span>
</pre><p>As you can see, &quot;target&quot; is a new wave object created to hold the sum. It is
made with the same number of data points as the source.</p><p>The subtract method __sub__ is identical to __add__ with the exception that
the '-' operator replaces the '+' operator.</p><p>Mutliplication is slightly more complicated because there are two ways it
can be done. If a wave is multiplied by a number then each data point is
multipled by that number resulting in a wave with the same shape
but with a different
amplitude. If two waves are multiplied together then the corresponding
data points are multiplied together resulting in a quite different wave.
We'll use both forms of multiplication.</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">__mul__</span> (<span class="py-src-parameter">self</span>, <span class="py-src-parameter">other</span>) :
   <span class="py-src-variable">target</span> = <span class="py-src-variable">wave</span>(<span class="py-src-variable">points</span>=<span class="py-src-variable">self</span>.<span class="py-src-variable">points</span>)
   <span class="py-src-keyword">if</span> <span class="py-src-variable">type</span>(<span class="py-src-variable">other</span>) == <span class="py-src-variable">type</span>(<span class="py-src-number">5</span>) <span class="py-src-keyword">or</span> <span class="py-src-variable">type</span>(<span class="py-src-variable">other</span>) == <span class="py-src-variable">type</span>(<span class="py-src-number">5.0</span>) :
      <span class="py-src-keyword">for</span> <span class="py-src-variable">i</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">range</span>(<span class="py-src-variable">self</span>.<span class="py-src-variable">points</span>) :
         <span class="py-src-variable">target</span>.<span class="py-src-variable">data</span>[<span class="py-src-variable">i</span>] = <span class="py-src-variable">self</span>.<span class="py-src-variable">data</span>[<span class="py-src-variable">i</span>] * <span class="py-src-variable">other</span>
   <span class="py-src-keyword">else</span> :
      <span class="py-src-keyword">for</span> <span class="py-src-variable">i</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">range</span>(<span class="py-src-variable">self</span>.<span class="py-src-variable">points</span>) :
         <span class="py-src-variable">target</span>.<span class="py-src-variable">data</span>[<span class="py-src-variable">i</span>] = <span class="py-src-variable">self</span>.<span class="py-src-variable">data</span>[<span class="py-src-variable">i</span>] * <span class="py-src-variable">other</span>.<span class="py-src-variable">data</span>[<span class="py-src-variable">i</span>]
   <span class="py-src-keyword">return</span> <span class="py-src-variable">target</span>
</pre><p>The final operation that we need for waves is to integrate them. For
those of you without a calculus background, this means finding the area
between a curve and the zero line. Where the function values are positive
the area is positive and where they are negative, the area is also negative.
Integral calculus has rules to compute such areas, but we will do
something much simpler. We'll let the computer simply compute the area
by finding the average function value in the range 0 to 2*pi and simply
multiplying that value by 2*pi. That is just what the following method does.</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">integral</span>(<span class="py-src-parameter">self</span>) :
   <span class="py-src-variable">ans</span> = <span class="py-src-number">0.0</span>
   <span class="py-src-keyword">for</span> <span class="py-src-variable">pt</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">self</span>.<span class="py-src-variable">data</span> : <span class="py-src-variable">ans</span> = <span class="py-src-variable">ans</span>+<span class="py-src-variable">pt</span>
   <span class="py-src-keyword">return</span> <span class="py-src-variable">ans</span>*<span class="py-src-number">2</span>*<span class="py-src-variable">pi</span>/<span class="py-src-variable">self</span>.<span class="py-src-variable">points</span>
</pre><p>This will introduce some small errors since our waves are sampled at a finite
number of data points. The curves are not completely smooth, but sort of
&quot;staircasey&quot;.</p><h2>Just Enough Tkinter<a name="auto2"></a></h2><p>Finally, we need to be able to plot our wave to the screen. There are actually
several ways to go about this but we'll use the Tkinter package which is fairly
straightforward for operations this simple. To use Tkinter, it must be installed
on your computer and if you are using Linux the you must be using the
X window system.</p><p>We will use just a few simple commands to plot our waves with Tkinter.
If you can, follow along from the Python interactive prompt.</p><pre class="python-interpreter">
&gt;&gt;&gt; from Tkinter import *
&gt;&gt;&gt; win = Tk()
</pre><p>If all is well, a small window should have popped up on your screen that
is framed and 200 pixels in both width and height. The variable &quot;win&quot;
is a reference to this window. (Windows users, don't panic. The window will
appear a little later.)</p><p>The next two commands create a &quot;canvas&quot; tied to the window onto which we may draw lines (and other
things as well). Since the canvas is dimensioned 400 pixels wide and high,
the window expands when the canvas is &quot;packed&quot; into it.</p><pre class="python-interpreter">
&gt;&gt;&gt; canvas = Canvas(win,height=400,width=400)
&gt;&gt;&gt; canvas.pack()
</pre><p>Finally we create a line from the origin (0,0) in the upper left corner to
the center of the canvas (and the window) at (200,200).</p><pre class="python-interpreter">
&gt;&gt;&gt; canvas.create_line(0,0,200,200)
</pre><p>Now, if you are using Windows you will need one more command before seeing the
window on the screen. The window must be &quot;run&quot; with the following</p><pre class="python-interpreter">
&gt;&gt;&gt; win.mainloop()
</pre><p>This will unfortunately keep your program (or the interactive mode) from proceeding
until the window is closed. That means that, unlike the Linux (and other Unix) users,
you won't be able to stack several windows on the screen.</p><p>That's really all we need to know to build our plot method. Let's look
at it now.</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">plot</span> (<span class="py-src-parameter">self</span>, <span class="py-src-parameter">title</span>=<span class="py-src-string">&quot;??&quot;</span>, <span class="py-src-parameter">pixHeight</span>=<span class="py-src-parameter">None</span>, <span class="py-src-parameter">maxY</span>=<span class="py-src-parameter">None</span>, <span class="py-src-parameter">others</span>=[]) :
   <span class="py-src-keyword">if</span> <span class="py-src-keyword">not</span> <span class="py-src-variable">pixHeight</span> : <span class="py-src-variable">pixHeight</span> = <span class="py-src-variable">self</span>.<span class="py-src-variable">points</span>*<span class="py-src-number">2</span>/<span class="py-src-number">3</span>   <span class="py-src-comment"># Pleasant ratio</span>
   <span class="py-src-variable">pixWidth</span> = <span class="py-src-variable">self</span>.<span class="py-src-variable">points</span>
   <span class="py-src-comment"># find max and min data to scale
</span>   <span class="py-src-keyword">if</span> <span class="py-src-keyword">not</span> <span class="py-src-variable">maxY</span> :
      <span class="py-src-variable">maxY</span> = <span class="py-src-variable">max</span> (<span class="py-src-variable">max</span>(<span class="py-src-variable">self</span>.<span class="py-src-variable">data</span>), -<span class="py-src-variable">min</span>(<span class="py-src-variable">self</span>.<span class="py-src-variable">data</span>))
      <span class="py-src-variable">offset</span> = <span class="py-src-variable">pixHeight</span>/<span class="py-src-number">2</span>
      <span class="py-src-variable">scale</span> = <span class="py-src-variable">offset</span>/<span class="py-src-variable">maxY</span>
</pre><p>This first part determines the scaling factor for the vertical &quot;y&quot; axis.
If maxY is supplied the window scales pixHeight to it, actually to twice
it's value, half above and half below the zero line. If maxY is not
specified, it is determined by the maximum positive (or minimum negative)
value in the data points.</p><p>Next a window and canvas are created and the zero line is drawn.</p><pre class="python">
...
   <span class="py-src-variable">win</span> = <span class="py-src-variable">Tk</span>()
   <span class="py-src-variable">win</span>.<span class="py-src-variable">title</span> (<span class="py-src-variable">title</span>)
   <span class="py-src-variable">canvas</span> = <span class="py-src-variable">Canvas</span>(<span class="py-src-variable">win</span>,<span class="py-src-variable">width</span>=<span class="py-src-variable">pixWidth</span>,<span class="py-src-variable">height</span>=<span class="py-src-variable">pixHeight</span>)
   <span class="py-src-comment"># create zero line
</span>   <span class="py-src-variable">canvas</span>.<span class="py-src-variable">create_line</span>(<span class="py-src-number">0</span>,<span class="py-src-variable">offset</span>,<span class="py-src-variable">pixWidth</span>,<span class="py-src-variable">offset</span>)
   <span class="py-src-variable">canvas</span>.<span class="py-src-variable">pack</span>()
</pre><p>Next &quot;plotOne&quot; is called to plot the wave. The parameters &quot;others&quot;
may be a list of other waves to plot as well with the same scale factor.</p><pre class="python">
...
   <span class="py-src-variable">self</span>.<span class="py-src-variable">plotOne</span> (<span class="py-src-variable">canvas</span>, <span class="py-src-variable">pixWidth</span>, <span class="py-src-variable">scale</span>, <span class="py-src-variable">offset</span>)
   <span class="py-src-keyword">for</span> <span class="py-src-variable">i</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">range</span>(<span class="py-src-variable">len</span>(<span class="py-src-variable">others</span>)) :
      <span class="py-src-variable">others</span>[<span class="py-src-variable">i</span>].<span class="py-src-variable">plotOne</span> (<span class="py-src-variable">canvas</span>, <span class="py-src-variable">pixWidth</span>, <span class="py-src-variable">scale</span>, <span class="py-src-variable">offset</span>)
      <span class="py-src-keyword">if</span> <span class="py-src-variable">sys</span>.<span class="py-src-variable">platform</span> == <span class="py-src-string">&quot;win32&quot;</span> : <span class="py-src-variable">win</span>.<span class="py-src-variable">mainloop</span>()
</pre><p>Finally the method &quot;plotOne&quot; draws lines between each of the data points scaled
to pixels. Notice that the first line drawn is for the second data point
when x==1.</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">plotOne</span> (<span class="py-src-parameter">self</span>, <span class="py-src-parameter">canvas</span>, <span class="py-src-parameter">pixWidth</span>, <span class="py-src-parameter">scale</span>, <span class="py-src-parameter">offset</span>) :
   <span class="py-src-keyword">for</span> <span class="py-src-variable">x</span> <span class="py-src-keyword">in</span> <span class="py-src-variable">range</span>(<span class="py-src-variable">pixWidth</span>) :
      <span class="py-src-variable">y</span> = <span class="py-src-variable">offset</span> - <span class="py-src-variable">self</span>.<span class="py-src-variable">data</span>[<span class="py-src-variable">x</span>] * <span class="py-src-variable">scale</span>
      <span class="py-src-keyword">if</span> <span class="py-src-variable">x</span> : <span class="py-src-variable">canvas</span>.<span class="py-src-variable">create_line</span>(<span class="py-src-variable">x</span>-<span class="py-src-number">1</span>,<span class="py-src-variable">yprev</span>,<span class="py-src-variable">x</span>,<span class="py-src-variable">y</span>)
      <span class="py-src-variable">yprev</span> = <span class="py-src-variable">y</span>
</pre><h2>Complex Waveforms<a name="auto3"></a></h2><p>Let's start making waves and see what they look like. We'll generate a
simple sine wave and its first harmonic (twice the frequency) at half the
amplitude.</p><pre class="python-interpreter">
&gt;&gt;&gt; import wave
&gt;&gt;&gt; a = wave.wave(formula=&quot;sin(x)&quot;)        # fundamental
&gt;&gt;&gt; b = wave.wave(formula=&quot;.5*sin(2*x)&quot;)   # harmonic
</pre><p>Next we'll plot both of them onto the same window.</p><pre class="python-interpreter">
&gt;&gt;&gt; a.plot(maxY=1.2, pixHeight=200, title=&quot;Sin(x) and .5sin(2*x)&quot;, others=[b])
</pre><p><img src="fig1.jpeg" /></p><p>Next let's compute and plot the sum of the two simple waves. Notice that
since both &quot;a&quot; and &quot;b&quot; are wave objects, their sum, computed by the
&quot;__add__&quot; method above is a seperate wave with its own data points.</p><pre class="python-interpreter">
&gt;&gt;&gt; c = a + b
&gt;&gt;&gt; c.plot(maxY=1.5, pixHeight=200, title=&quot;Sin(x) + .5sin(2*x)&quot;)
</pre><p>Or more consisely.</p><pre class="python-interpreter">
&gt;&gt;&gt; (a+b).plot(maxY=1.5, pixHeight=200, title=&quot;Sin(x) + .5sin(2*x)&quot;)
</pre><p>And the result is.</p><p><img src="fig2.jpeg" /></p><p>Now it's pretty simple to generate a complex waveform from simple waveforms.
Much trickier is to extract the simple waves from the complex. But that
is exactly what we would need to do in order to see the pattern of
harmonic frequencies that distinguish a violin from a piano or, going
back to japanese vowels, the &quot;ah&quot; sound from the &quot;ee&quot; sound.</p><p>Fourier provided an ingeneous method for this. To understand it we need
to consider the integrals of our simple waves.</p><pre class="python-interpreter">
&gt;&gt;&gt; print a.integral(), b.integral(), c.integral()
-1.143366892e-16 -1.63003354337e-16 -3.61866356668e-17
</pre><p>The integrals are basically zero. But we must expect that since in each wave
there is just as much area below the center line as above. The waves are
symetrical around the zero line. But supposing we multiply both
&quot;a&quot; and &quot;b&quot; by &quot;-sin(x)&quot;</p><pre class="python-interpreter">
&gt;&gt;&gt; mx = wave.wave(formula=&quot;-sin(x)&quot;)
&gt;&gt;&gt; c = a*mx
&gt;&gt;&gt; c.plot(maxY=1.2, pixHeight=200, title=&quot;Sin(x) * -sin(x)&quot;)
&gt;&gt;&gt; print c.integral()
-3.14159265359
</pre><p><img src="fig3.jpeg" /></p><p>Notice that for our fundamental frequency this multiplication takes the
curve below the centerline and yields an area of -pi. Let's try the same
thing for our first harmonic.</p><pre class="python-interpreter">
&gt;&gt;&gt; mx = wave.wave(formula=&quot;-sin(2*x)&quot;)
&gt;&gt;&gt; c = b*mx
&gt;&gt;&gt; c.plot(maxY=1.2, pixHeight=200, title=&quot;Sin(2*x) * -sin(x)&quot;)
&gt;&gt;&gt; print c.integral()
-1.74286132071e-16          (basically zero)
</pre><p><img src="fig4.jpeg" /></p><p>We can see that there are still equal areas above and below the center
line. You can try this on other harmonics and see that this always holds
true. Only the fundamental frequency will yield a non-zero area of -pi
times its amplitude.</p><p>This leads to the following technique to &quot;remove&quot; first the fundamental
frequency followed by the successive harmonics. We multiply the complex
wave by &quot;-sin(n*x)&quot; where n is 1,2,3... and then compute the integral
of the result. The integral divided by -pi is the amplitude of the
nth harmonic. We then form a wave with that amplitude and frequency and
subtract it from the complex wave leaving the remaining harmonics. When all
of the harmonics have been extracted our complex wave will be reduced to
a flat line of zero amplitude. But we will have the necessary information
to reconstruct the complex wave anytime we want.</p><p>The recombination of simple waves to complex is how music synthesizers
work and is also the basis for MIDI music format.</p><h2>Fourier Analysis of a Mystery Wave<a name="auto4"></a></h2><p>Let's apply the above technique to the following wave form</p><p><img src="fig5.jpeg" /></p><p>which we have referenced by the variable &quot;mystery&quot;. How we got this
wave is not important. It might be captured from a microphone to a wave
file. Let's start with the fundamental frequency and integrate its product
with &quot;-sin(x)&quot;</p><pre class="python-interpreter">
&gt;&gt;&gt; d = mystery
&gt;&gt;&gt; (d*wave.wave(formula=&quot;-sin(x)&quot;)).integral()
-3.1415926535897931
&gt;&gt;&gt;
</pre><p>The result is -pi which means the amplitude of the fundamental frequency
must be one. Let's now subtract that from &quot;d&quot; leaving only the harmonics.</p><pre class="python-interpreter">
&gt;&gt;&gt; d = d - wave.wave(formula=&quot;sin(x)&quot;)
&gt;&gt;&gt; d.plot(maxY=1.2, pixHeight=200, title=&quot;Mystery wave - without fundamental&quot;)
&gt;&gt;&gt;
</pre><p>The result looks like this</p><p><img src="fig6.jpeg" /></p><p>That certainly looks simpler. Let's now try the harmonic at twice the
fundamental frequency.</p><pre class="python-interpreter">
&gt;&gt;&gt; (d*wave.wave(formula=&quot;-sin(2*x)&quot;)).integral()
-7.9727087825085978e-17
&gt;&gt;&gt;
</pre><p>With e-17, this is basically zero. Let's keep going, subtracting out
harmonics as we find them.</p><pre class="python-interpreter">
&gt;&gt;&gt; (d*wave.wave(formula=&quot;-sin(3*x)&quot;)).integral()
-1.0471975511965983
&gt;&gt;&gt; d = d - wave.wave(formula=&quot;-1.0471975511965983*sin(3*x)/-pi&quot;)
&gt;&gt;&gt; d.plot(maxY=1)
</pre><p><img src="fig7.jpeg" /></p><pre class="python-interpreter">
&gt;&gt;&gt; (d*wave.wave(formula=&quot;-sin(4*x)&quot;)).integral()
-2.5293858853722756e-17
&gt;&gt;&gt; (d*wave.wave(formula=&quot;-sin(5*x)&quot;)).integral()
-0.62831853071795829
&gt;&gt;&gt; d = d - wave.wave(formula=&quot;-0.62831853071795829*sin(5*x)/-pi&quot;)
&gt;&gt;&gt; d.plot(maxY=1)
</pre><p><img src="fig8.jpeg" /></p><pre class="python-interpreter">
&gt;&gt;&gt; (d*wave.wave(formula=&quot;-sin(6*x)&quot;)).integral()
-4.8554263124133835e-17
&gt;&gt;&gt; (d*wave.wave(formula=&quot;-sin(7*x)&quot;)).integral()
-0.44879895051282731
&gt;&gt;&gt; d = d - wave.wave(formula=&quot;-0.44879895051282731*sin(7*x)/-pi&quot;)
&gt;&gt;&gt; d.plot(maxY=1)
</pre><p><img src="fig9.jpeg" /></p><p>As the final plot shows, all harmonics are basically gone.</p><p>Our mystery wave was the begining of a square wave with just the first
few harmonics. The square has an interesting set of harmonics. Only
the odd harmonics are present. Their amplitudes also decrease in an
orderly way.</p><pre class="shell">
sin(x) + sin(3*x)/3 + sin(5*x)/5 + sin(7*x)/7 + sin(9*x)/9 + ...
</pre><p>If you check the non-zero integrals above you'll find that
they are in fact -pi/3, -pi/5, and -pi/7 except for some very small error due
to the approximations discussed above.</p><p>This is encapsulated in the wave.fft method at the bottom of the wave class. A test function
demonstrates its use</p><pre class="python">
<span class="py-src-keyword">def</span> <span class="py-src-identifier">test</span>() :
    <span class="py-src-variable">p1</span> = <span class="py-src-variable">wave</span>(<span class="py-src-variable">formula</span>=<span class="py-src-string">&quot;sin(x)/1&quot;</span>)
    <span class="py-src-variable">p3</span> = <span class="py-src-variable">wave</span>(<span class="py-src-variable">formula</span>=<span class="py-src-string">&quot;sin(3*x)/3&quot;</span>)
    <span class="py-src-variable">p5</span> = <span class="py-src-variable">wave</span>(<span class="py-src-variable">formula</span>=<span class="py-src-string">&quot;sin(5*x)/5&quot;</span>)
    <span class="py-src-variable">mys</span> = <span class="py-src-variable">p1</span>+<span class="py-src-variable">p3</span>+<span class="py-src-variable">p5</span>
    <span class="py-src-variable">mys</span>.<span class="py-src-variable">fft</span>()
    
<span class="py-src-keyword">if</span> <span class="py-src-variable">__name__</span> == <span class="py-src-string">&quot;__main__&quot;</span> : <span class="py-src-variable">test</span>()
</pre><pre class="shell">
$ python wave.py
Harmonic= 1  Amplitude=1.0000
Harmonic= 3  Amplitude=0.3333
Harmonic= 5  Amplitude=0.2000
</pre><h2>Where from here?<a name="auto5"></a></h2><p>Here are a few things you might try.</p><p>Write a Python function to automate the steps above until all datapoints are below
some small noise factor. Your function takes a wave object as input and returns
a list of the coeffients.</p><p>The formula &quot;sin(x)-sin(2*x)/2+sin(3*x)/3-sin(4*x)/4+ ...&quot; creates triangular
sawtooth waves. Write a function to create a sawtooth wave which takes the number
of terms as an input parameter and returns the wave. Plot the wave.</p><p id="Footer"><a href="http://www.gnu.org/copyleft/copyleft.html">
Copyright</a>&copy; 2003-2009 Chris Meyers</p></div><p><a href="../index.html">Index</a></p></body></html>